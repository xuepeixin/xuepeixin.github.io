I"!<h1 id="几何">几何</h1>

<p>几何表示方法分为</p>
<ul>
  <li><strong>隐式表示方法</strong>（Implicit Representation）:给定<strong>满足的关系</strong>而不给定具体的成员
    <ul>
      <li>如$x^2+y^2+z^2=1$，表示满足该公式的所有点的集合</li>
      <li>更容易判断任意<strong>一个点和该几何形状的空间关系</strong>，如判断一个点在不在几何内</li>
      <li>更容易计算光线和表面的交点</li>
      <li>更容易处理如流体等情况</li>
      <li>不容易表示复杂的模型</li>
    </ul>
  </li>
  <li><strong>显式表示方法</strong>（Explicit Representation）:通过<strong>参数映射</strong>或者<strong>点云</strong>的方式表示
    <ul>
      <li>参数映射方法：如$f: \mathcal{R}^2\rightarrow\mathcal{R}^3;(u,v)\rightarrow(x,y,z)$</li>
      <li>点云：可以表示成一系列点的集合。更常用于大型数据集中。</li>
      <li>不容易判断一个点与几何形状的空间关系</li>
    </ul>
  </li>
</ul>

<h2 id="曲线的表示">曲线的表示</h2>

<h3 id="贝塞尔曲线">贝塞尔曲线</h3>

<p>贝塞尔曲线是由多个控制点线性组合得到的连续曲线。对于控制点${P_0,P_1,P_2,\cdots P_n}$。可以由一个区间为$(0,1)$参数$t$生成一条贝塞尔曲线。生成方法如下图所示,相邻的两个控制点${P_i^k,P_{i+1}^k}$由权重系数$t$加权得到$P^{k+1}_i$。对于n个控制点，最终会生成点$P^n_0$，该点即为n阶贝塞尔曲线上的一点。</p>

<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-bezier.png" />
</center>

<p>对于三个控制点的贝塞尔曲线，在线段$P_0P_1$和$P_1P_2$上取相同比例t位置的点$P^1_0$和$P^1_1$，连接$P^1_0P^1_1$。同样，对$P^1_0P^1_1$取线段比例t位置的点$P^2_0$，$P^2_0$为最终生成的采样点。用公式表示为：</p>

<p>\(\begin{matrix}
P^2_0&amp;=(1-t)((1-t)P_0+tP_1)+t((1-t)P_1+tP_2)\\
&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2
\end{matrix}\)</p>
<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-bezier0.png" />
</center>

<p>下图是四个控制点${P_1,P_2,P_3}$生成的贝塞尔曲线中一个点的示意图。其中$P^3_0$为最终生成的采样点，它是贝塞尔曲线上的一个点。用公式表示为：</p>

<p>\(\begin{matrix}
P^3_0&amp;=(1-t)((1-t)((1-t)P_0+tP_1)+t((1-t)P_1+tP_2))+\\
&amp;t((1-t)((1-t)P_1+tP_2)+t((1-t)P_2+tP_3))\\
&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3
\end{matrix}\)</p>
<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-bezier1.png" />
</center>

<p>贝塞尔曲线的显式表达式为</p>

\[P^n_0(t)=\sum^n_{j=0}P_jB^n_j(t)\]

<p>其中$B^n_j(t)$被称为伯恩斯坦多项式（Bernstein polynomial），其具体表达式为：</p>

\[B^n_j(t)=C^n_it^i(1-t)^{n-i}\]

<h4 id="性质">性质</h4>

<ul>
  <li>$P^n_0(0)=P_0$;$P^n_0(1)=P_n$</li>
  <li>反射变换性质：直接对控制点做仿射变换等效于对曲线做仿射变换</li>
  <li>凸包性质：曲线在控制点组成的凸包内</li>
</ul>

<h4 id="逐段贝塞尔曲线">逐段贝塞尔曲线</h4>

<p>当控制点过多时，曲线的调整会变得复杂。因此通常将三次贝塞尔曲线作为一个曲线段，然后组合成复杂的曲线。如在PhotoShop中钢笔工具就是使用三次贝塞尔曲线实现曲线的调整。</p>

<h4 id="贝塞尔曲面">贝塞尔曲面</h4>
<p>该方法类似双线性插值的思想，可以理解为分为水平方向和垂直方向两个部分，先对水平方向计算得到点，再将这些点作为垂直方向的控制点。</p>

<h3 id="b样条b-splines">B样条（B-splines）</h3>

<p>在贝塞尔曲线中，改动一个控制点会影响到整个曲线，只有通过分段的方式才能解决这个问题。而B样条不需要分段就能使得改动一个点只会影响一部分的曲线。</p>

<h2 id="网格mesh">网格（Mesh）</h2>

<h3 id="网格细分mesh-subdivision">网格细分（mesh subdivision）</h3>

<h4 id="loop-细分">Loop 细分</h4>

<ol>
  <li>将三角形分成四个</li>
</ol>
<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision.png" />
</center>

<ol>
  <li>根据权重调整顶点位置
    <ul>
      <li>对于下图中新增的白点，用A、B、C、D点加权平均取得。</li>
    </ul>
  </li>
</ol>
<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision1.png" />
</center>

<ul>
  <li>对于原有的顶点，用周围的顶点加权，加权方法为
    <ul>
      <li>point=(1-n<em>u)</em>原始顶点+u*所有相邻的顶点位置</li>
      <li>n 为点的度，即连接的边的个数</li>
      <li>u为权重，具体取值如下图所示</li>
    </ul>
  </li>
</ul>

<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision2.png" />
</center>

<h4 id="catmull-clark-细分适用于通用的网格">Catmull-Clark 细分（适用于通用的网格）</h4>

<p>Loop 细分只能够细分三角形网格，而Catmull-Clark 细分适用于通用的网格。
首先定义一些概念：</p>
<ol>
  <li>非四边形面（Non-quad face）：表面不是四边形的面</li>
  <li>奇异点（Extaordinary vertex）:点的度不为4，即连接的边数为4</li>
</ol>

<h5 id="细分方法如下图所示对于每一条边取边的中点对于每一个面取面的中点并将面的中点和每一个边的中点连接起来">细分方法：如下图所示，对于每一条边，取边的中点；对于每一个面，取面的中点；并将面的中点和每一个边的中点连接起来。</h5>

<center>
<table><tr>
<td>&lt;img src=https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision3.png height=200 border=0&gt;</td>
<td>&lt;img src=https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision4.png height=200 border=0&gt;</td>
</tr></table>
</center>

<p>一次细分之后，所有非四边形面都会消失，并且每个非四边形面都会引入一个奇异点。并且之后的奇异点数量不会再再增加啊</p>

<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision5.png" height="400" />
</center>

<h5 id="顶点调整方法">顶点调整方法</h5>

<ol>
  <li>对于面上的点：用面上的顶点加权得到</li>
  <li>对于边上的点：用边连接的两个面上的点、边连接的点加权得到</li>
  <li>对于旧的点：用相邻面上的点、相邻边上的点、自身点加权得到</li>
</ol>

<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_subdivision6.png" height="400" />
</center>

<h3 id="网格简化mesh-simplificaton">网格简化（mesh simplificaton）</h3>

<p>对于一些较简单的模型或者观测距离很远，有时候不需要很多的网格数量，这就需要对网格进行简化。</p>

<h4 id="边坍缩edge-collapsing">边坍缩（Edge Collapsing）</h4>

<p>边坍缩的基本方法就是去掉一条边，并将边两端的点连接到一块。这个次想法面临两个问题</p>
<ol>
  <li>要坍缩哪一条边</li>
  <li>坍缩之后的顶点位置怎么确定</li>
</ol>

<p>解决这两个问题，就要用到二次误差度量（Quadric Error Metrics）方法。</p>

<h5 id="二次误差度量quadric-error-metrics">二次误差度量（Quadric Error Metrics）</h5>

<p>二次误差度量表示的是一个点到与它有关系的面的距离的平方和。最小化二次误差就是将该点放置到一个位置，使得二次误差最小。这就成为一个优化问题。</p>
<center>
    <img src="https://xpx-picbed.oss-cn-beijing.aliyuncs.com/blog/2020/04/geometry-mesh_simplification.png" height="200" />
</center>

<h5 id="坍缩哪一条边">坍缩哪一条边</h5>

<p>对于每一条边，都可以计算坍缩之后的最小的二次误差。因此，对于整个模型，我们首先坍缩二次误差最小的哪一条边。</p>

<h5 id="算法流程">算法流程</h5>

<ol>
  <li>计算所有边的坍缩的最小二次距离误差，并构建成堆的结构</li>
  <li>坍缩最小二次距离误差最小的边，同时由于边位置发生变化，需要更新最小二次距离误差的堆结构</li>
</ol>

<h3 id="网格规则化mesh-regularization">网格规则化（mesh regularization）</h3>
:ET